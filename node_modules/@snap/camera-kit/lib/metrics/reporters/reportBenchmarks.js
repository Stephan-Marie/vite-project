import { __awaiter } from "tslib";
import { metricsClientFactory } from "../../clients/metricsClient";
import { configurationToken } from "../../configuration";
import { Injectable } from "../../dependency-injection/Injectable";
import { TypedCustomEvent } from "../../events/TypedCustomEvent";
import { metricsEventTargetFactory } from "../metricsEventTarget";
import { Histogram } from "../operational/Histogram";
// Allowlist the benchmarks we wish to report.
const reportableBenchmarks = ["gflops"];
export const reportBenchmarks = Injectable("reportBenchmarks", [metricsEventTargetFactory.token, metricsClientFactory.token, configurationToken], (metricsEventTarget, metrics, config) => __awaiter(void 0, void 0, void 0, function* () {
    if (config.lensPerformance === undefined)
        return;
    // Safety: config.lensPerformance cannot reject â€“ all Promises contained in CameraKitConfiguration have
    // catch blocks which return a default value.
    const lensPerformance = yield config.lensPerformance;
    const baseBenchmark = {
        name: "benchmarkComplete",
        performanceCluster: `${lensPerformance.cluster}`,
        webglRendererInfo: lensPerformance.webglRendererInfo,
    };
    const dimensions = { performance_cluster: lensPerformance.cluster.toString() };
    for (const benchmark of lensPerformance.benchmarks) {
        if (!reportableBenchmarks.includes(benchmark.name))
            continue;
        const benchmarkComplete = Object.assign(Object.assign({}, baseBenchmark), { benchmarkName: benchmark.name, benchmarkValue: benchmark.value });
        metricsEventTarget.dispatchEvent(new TypedCustomEvent("benchmarkComplete", benchmarkComplete));
        metrics.setOperationalMetrics(Histogram.level(`benchmark.${benchmark.name}`, benchmark.value, dimensions));
    }
}));
//# sourceMappingURL=reportBenchmarks.js.map