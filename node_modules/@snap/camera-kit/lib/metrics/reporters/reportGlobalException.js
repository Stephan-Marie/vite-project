import { isState } from "@snap/state-management";
import { filter, map, scan, Subject, takeUntil } from "rxjs";
import { entries } from "../../common/entries";
import { ensureError, stringifyError } from "../../common/errorHelpers";
import { Injectable } from "../../dependency-injection/Injectable";
import { TypedCustomEvent } from "../../events/TypedCustomEvent";
import { logEntriesFactory } from "../../logger/logEntries";
import { logLevelMap } from "../../logger/logger";
import { metricsEventTargetFactory } from "../metricsEventTarget";
import { metricsClientFactory } from "../../clients/metricsClient";
import { Count } from "../operational/Count";
const logMethods = entries(logLevelMap).map(([level]) => level);
// How many log entries to include as the error context
const maxBufferedEntries = 15;
const contextSeparator = "\n\n----------------- Context -----------------\n\n";
const methodLength = logMethods.reduce((max, method) => Math.max(max, method.length), 0);
export function getContextString(logEntries) {
    const result = [];
    for (const { entry, count, lastTime } of logEntries) {
        const time = entry.time.toISOString();
        const method = entry.level.padStart(methodLength);
        const messages = entry.messages.map(prettyPrintMessage).join(" ");
        let dupSuffix = count > 1 ? ` (Repeated ${count} times with the last occurrence at ${lastTime.toISOString()})` : "";
        result.push(`${time} [${entry.module}] ${method}: ${messages}${dupSuffix}`);
    }
    return result.join("\n");
}
/**
 * Pretty print a log message.
 */
function prettyPrintMessage(message) {
    if (message instanceof Error)
        return stringifyErrorMessage(message);
    if (message instanceof Date)
        return message.toISOString();
    return message + "";
}
/**
 * Returns an error message for a given error, and also appends the error message of any nested error,
 * if one exists. It DOES NOT append error stack trace.
 * @param error Error to stringify.
 * @returns Error message including nested error messages.
 */
function stringifyErrorMessage(error) {
    const cause = error.cause ? `; Caused by ${stringifyErrorMessage(ensureError(error.cause))}` : "";
    return `${error.name}: ${error.message}${cause}`;
}
export function reportExceptionToBlizzard(logEntries, metricsEventTarget, metrics, lensState) {
    logEntries
        .pipe(scan(({ entries }, newEntry) => {
        const lastEntry = entries[entries.length - 1];
        const isNewEntryRepeated = lastEntry &&
            lastEntry.entry.messages.join() === newEntry.messages.join() &&
            lastEntry.entry.level === newEntry.level;
        if (isNewEntryRepeated) {
            lastEntry.count += 1;
            lastEntry.lastTime = newEntry.time;
        }
        else {
            entries.push({
                entry: newEntry,
                count: 1,
                lastTime: newEntry.time,
            });
        }
        return {
            entries: entries.slice(-maxBufferedEntries),
            recent: newEntry,
        };
    }, 
    // Start with a dummy recent entry -- it gets overridden each time we handle a log entry.
    { entries: [], recent: { time: new Date(), module: "any", level: "debug", messages: [] } }), filter(({ recent }) => recent.level === "error"), map(({ entries, recent }) => ({
        context: entries,
        error: recent.messages.find((e) => e instanceof Error),
    })), filter(({ error }) => !!error))
        .subscribe(({ error, context }) => {
        const currentLensState = lensState === null || lensState === void 0 ? void 0 : lensState.getState();
        const lensId = currentLensState && !isState(currentLensState, "noLensApplied") ? currentLensState.data.id : "none";
        metricsEventTarget.dispatchEvent(new TypedCustomEvent("exception", {
            name: "exception",
            lensId,
            type: error.name,
            reason: `${stringifyError(error)}${contextSeparator}${getContextString(context)}`,
        }));
        metrics.setOperationalMetrics(Count.count("handled_exception", 1, { type: error.name }));
    });
}
/**
 * Reports log entries to Blizzard when there is no CameraKit session yet.
 *
 * @internal
 */
export const reportGlobalException = Injectable("reportGlobalException", [logEntriesFactory.token, metricsEventTargetFactory.token, metricsClientFactory.token], (logEntries, metricsEventTarget, metrics) => {
    // Initially we log exceptions without any lens context
    const cancellationSubject = new Subject();
    reportExceptionToBlizzard(logEntries.pipe(takeUntil(cancellationSubject)), metricsEventTarget, metrics);
    // Later session scope reporter triggers cancellation of the global one
    // and initiates exception reporting with a lens context
    return {
        attachLensContext: (lensState) => {
            cancellationSubject.next();
            reportExceptionToBlizzard(logEntries, metricsEventTarget, metrics, lensState);
        },
    };
});
//# sourceMappingURL=reportGlobalException.js.map