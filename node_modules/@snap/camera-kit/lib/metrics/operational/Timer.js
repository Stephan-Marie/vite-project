import { __awaiter } from "tslib";
import { getTimeMs } from "../../common/time";
import { Metric, joinMetricNames, serializeMetricDimensions } from "./Metric";
/** @internal */
export class Timer extends Metric {
    constructor(name, dimensions = {}) {
        super(name, dimensions);
        this.name = name;
        this.startTime = getTimeMs();
        this.stopped = false;
        this.marks = new Set();
        this.measures = new Set();
    }
    /**
     * Return all measures created by this Timer and any child timers.
     */
    getMeasures() {
        return Array.from(this.measures.values()).concat(...Array.from(this.marks.values()).map((mark) => mark.getMeasures()));
    }
    /**
     * Create a child Timer, using this Timer's name as a prefix when naming the new Timer. Any measures made with the
     * child Timer will be included when calling `getMeasures()` on this Timer, or when calling `toOperationalMetric`
     * on this Timer.
     *
     * @example
     * ```ts
     * const parent = new Timer('parent')
     * const child = parent.mark('child') // child metric name is parent_child.
     *
     * child.measure()
     * const measures = parent.getMeasures() // has one element.
     * ```
     *
     * @param name
     * @param dimensions If omitted, the child timer will NOT inherit dimensions from the parent -- if the child timer
     * should re-use the parent's dimensions, this must be done explicitly by passing the parent's dimensions as an
     * argument here.
     * @returns A child Timer.
     */
    mark(name, dimensions = {}) {
        const mark = new Timer(joinMetricNames([this.name, name]), dimensions);
        if (this.stopped)
            mark.stop();
        this.marks.add(mark);
        return mark;
    }
    measure(nameOrDimensions, maybeDimensions) {
        if (this.stopped)
            return undefined;
        const name = typeof nameOrDimensions === "string" ? nameOrDimensions : "";
        const dimensions = typeof nameOrDimensions === "string" ? maybeDimensions : nameOrDimensions;
        const fullName = joinMetricNames([this.name, name]);
        const measure = {
            name: fullName,
            duration: getTimeMs() - this.startTime,
            dimensions: dimensions !== null && dimensions !== void 0 ? dimensions : this.dimensions,
        };
        this.measures.add(measure);
        return measure;
    }
    /**
     * Remove all measures from this Timer and any child timers previously created by calls to `mark()`.
     */
    clear() {
        this.measures.clear();
        this.marks.forEach((mark) => mark.clear());
    }
    /**
     * Prevent any future measures from being created by this Timer or any child timers.
     */
    stop() {
        this.stopped = true;
        this.marks.forEach((mark) => mark.stop());
    }
    /**
     * Report this metric using {@link MetricsClient}.
     *
     * After reporting, the Timer can longer be used. Its internal state is cleared and cannot be updated. Calling this
     * method a second time will no-op.
     *
     * @param reporter All measurements will be reported using the given reporter.
     */
    stopAndReport(client) {
        return __awaiter(this, void 0, void 0, function* () {
            client.setOperationalMetrics(this);
            this.stop();
            this.clear();
        });
    }
    /**
     * Convert all measures from this Timer and from any child timers into an array of {@link OperationalMetric}
     * objects, which can be sent to the backend.
     *
     * @returns
     */
    toOperationalMetric() {
        const timestamp = new Date();
        return this.getMeasures().map((measure) => ({
            name: `${measure.name}${serializeMetricDimensions(measure.dimensions)}`,
            timestamp,
            metric: {
                $case: "latencyMillis",
                latencyMillis: `${Math.ceil(measure.duration)}`,
            },
        }));
    }
}
//# sourceMappingURL=Timer.js.map